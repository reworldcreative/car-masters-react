"use strict";(self.webpackChunkwebpackreact=self.webpackChunkwebpackreact||[]).push([[1268],{5609:function(e,t,r){r.d(t,{l:function(){return l}});var n=r(4873),s=r(4470),o=r(4345);function i(e){if("object"!=typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return!(null!==t&&t!==Object.prototype&&null!==Object.getPrototypeOf(t)||Symbol.toStringTag in e||Symbol.iterator in e)}var c=r(6702),a=r(5654);const f=function(e){const t=this.constructor.prototype,r=t[e],n=function(){return r.apply(n,arguments)};Object.setPrototypeOf(n,t);const s=Object.getOwnPropertyNames(r);for(const e of s){const t=Object.getOwnPropertyDescriptor(r,e);t&&Object.defineProperty(n,e,t)}return n};var h=r(6624);const p={}.hasOwnProperty;class u extends f{constructor(){super("copy"),this.Compiler=void 0,this.Parser=void 0,this.attachers=[],this.compiler=void 0,this.freezeIndex=-1,this.frozen=void 0,this.namespace={},this.parser=void 0,this.transformers=(0,c.r)()}copy(){const e=new u;let t=-1;for(;++t<this.attachers.length;){const r=this.attachers[t];e.use(...r)}return e.data(s(!0,{},this.namespace)),e}data(e,t){return"string"==typeof e?2===arguments.length?(w("data",this.frozen),this.namespace[e]=t,this):p.call(this.namespace,e)&&this.namespace[e]||void 0:e?(w("data",this.frozen),this.namespace=e,this):this.namespace}freeze(){if(this.frozen)return this;const e=this;for(;++this.freezeIndex<this.attachers.length;){const[t,...r]=this.attachers[this.freezeIndex];if(!1===r[0])continue;!0===r[0]&&(r[0]=void 0);const n=t.call(e,...r);"function"==typeof n&&this.transformers.use(n)}return this.frozen=!0,this.freezeIndex=Number.POSITIVE_INFINITY,this}parse(e){this.freeze();const t=m(e),r=this.parser||this.Parser;return y("parse",r),r(String(t),t)}process(e,t){const r=this;return this.freeze(),y("process",this.parser||this.Parser),d("process",this.compiler||this.Compiler),t?n(void 0,t):new h(n);function n(n,s){const i=m(e),c=r.parse(i);function a(e,r){e||!r?s(e):n?n(r):((0,o.ok)(t,"`done` is defined if `resolve` is not"),t(void 0,r))}r.run(c,i,(function(e,t,n){if(e||!t||!n)return a(e);const s=t,o=r.stringify(s,n);var i;"string"==typeof(i=o)||function(e){return Boolean(e&&"object"==typeof e&&"byteLength"in e&&"byteOffset"in e)}(i)?n.value=o:n.result=o,a(e,n)}))}}processSync(e){let t,r=!1;return this.freeze(),y("processSync",this.parser||this.Parser),d("processSync",this.compiler||this.Compiler),this.process(e,(function(e,s){r=!0,(0,n.N)(e),t=s})),b("processSync","process",r),(0,o.ok)(t,"we either bailed on an error or have a tree"),t}run(e,t,r){g(e),this.freeze();const n=this.transformers;return r||"function"!=typeof t||(r=t,t=void 0),r?s(void 0,r):new h(s);function s(s,i){(0,o.ok)("function"!=typeof t,"`file` canâ€™t be a `done` anymore, we checked");const c=m(t);n.run(e,c,(function(t,n,c){const a=n||e;t?i(t):s?s(a):((0,o.ok)(r,"`done` is defined if `resolve` is not"),r(void 0,a,c))}))}}runSync(e,t){let r,s=!1;return this.run(e,t,(function(e,t){(0,n.N)(e),r=t,s=!0})),b("runSync","run",s),(0,o.ok)(r,"we either bailed on an error or have a tree"),r}stringify(e,t){this.freeze();const r=m(t),n=this.compiler||this.Compiler;return d("stringify",n),g(e),n(e,r)}use(e,...t){const r=this.attachers,n=this.namespace;if(w("use",this.frozen),null==e);else if("function"==typeof e)f(e,t);else{if("object"!=typeof e)throw new TypeError("Expected usable value, not `"+e+"`");Array.isArray(e)?a(e):c(e)}return this;function o(e){if("function"==typeof e)f(e,[]);else{if("object"!=typeof e)throw new TypeError("Expected usable value, not `"+e+"`");if(Array.isArray(e)){const[t,...r]=e;f(t,r)}else c(e)}}function c(e){if(!("plugins"in e)&&!("settings"in e))throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");a(e.plugins),e.settings&&(n.settings=s(!0,n.settings,e.settings))}function a(e){let t=-1;if(null==e);else{if(!Array.isArray(e))throw new TypeError("Expected a list of plugins, not `"+e+"`");for(;++t<e.length;){o(e[t])}}}function f(e,t){let n=-1,o=-1;for(;++n<r.length;)if(r[n][0]===e){o=n;break}if(-1===o)r.push([e,...t]);else if(t.length>0){let[n,...c]=t;const a=r[o][1];i(a)&&i(n)&&(n=s(!0,a,n)),r[o]=[e,n,...c]}}}}const l=(new u).freeze();function y(e,t){if("function"!=typeof t)throw new TypeError("Cannot `"+e+"` without `parser`")}function d(e,t){if("function"!=typeof t)throw new TypeError("Cannot `"+e+"` without `compiler`")}function w(e,t){if(t)throw new Error("Cannot call `"+e+"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")}function g(e){if(!i(e)||"string"!=typeof e.type)throw new TypeError("Expected node, got `"+e+"`")}function b(e,t,r){if(!r)throw new Error("`"+e+"` finished async. Use `"+t+"` instead")}function m(e){return function(e){return Boolean(e&&"object"==typeof e&&"message"in e&&"messages"in e)}(e)?e:new a.k(e)}}}]);